---
title: "Time series graphics"
subtitle: "Lab Session 2"
author: "Dr.Priyanga Talagala"
date: "30/06/2024"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(
  echo = TRUE, 
  cache = TRUE, 
  dev = 'png')
```

# Main packages required

```r
# Data manipulation and plotting functions
library(tidyverse)
# Time series manipulation
library(tsibble)
# Tidy time series data
library(tsibbledata)
# Time series graphics and statistics
library(feasts)
# Forecasting functions
library(fable)
```

```r
# All of the above
library(fpp3)
```

## Install required packages

```r
install.packages(c( "tidyverse", "fpp3"))
```


# Time Series in R

```{r}
library(tidyverse)
library(fpp3)
```

## `tsibble` objects

- A tsibble allows storage and manipulation of multiple time series in R.
- It contains:
  - An index: time information about the observation
  - Measured variable(s): numbers of interest
  -  Key variable(s): optional unique identifiers for each
series
  - It works with tidyverse functions.

**Example 1**

```{r}
global_economy
```

**Example 2**

```{r}
tourism
```

## The `tsibble` index

```{r}
set.seed(1)
ts <- tsibble(t = seq(36), y = rnorm(36), index = t) 
ts
```

```{r}
mydata <- tsibble(
  year = 2016:2020,
  y = c(123, 39, 78, 52, 110),
  index = year
) 

mydata

```

###  `tibble` vs `tsibble`
```{r}
#tibble
mytibble <- tibble(
  year = 2012:2016,
  y = c(123, 39, 78, 52, 110)
)
mytibble
```

```
mytsibble <- mytibble |> as_tsibble(index = year) 

mytsibble
```

###  Pipe `|>` Operator

- The pipe operator will forward a value, or the result of an expression, into the next function call/expression.
- For instance a function to filter data can be written as:

```r

head(as_tsibble(mytibble, index = year))
```
or
```r
mytibble |> as_tsibble(index = year) |> head()
```

- Both functions complete the same task
- It improves the readability and clarity
- We read the `|>` operator  as "and then"
- Example: “take mytibble *and then* coerce to a tsibble object *and then* return the first part of the object”

<!-- https://towardsdatascience.com/an-introduction-to-the-pipe-in-r-823090760d64

A Guide to the Pipe in R-->

-  For observations more frequent than once per year, we need to use a time class function on the index.

```{r}
z <- tibble(
  Month = paste(2019, month.abb[1:5]), 
  Observation = c(50, 23, 34, 30, 25))
z
```

<!-- month.abb: the three-letter abbreviations for the English month names;-->


```{r}
z |>
mutate(Month = yearmonth(Month)) |> as_tsibble(index = Month)
```

- Common time index variables can be created with these functions:

Frequency | Function
----------|-----------
Annual    | `start:end`
Quarterly | `yearquarter()`
Monthly   | `yearmonth()`
Weekly    | `yearweek()`
Daily     | `as_date(), ymd()`
Sub-daily | `as_datetime()`

## Working with `tsibble` objects

```{r}
# Monthly Medicare Australia prescription data

PBS
```

### We can use the `filter()` function to select rows

```{r}
PBS |>
filter(ATC2 == "A10")
```

### We can use the `select()` function to select columns.

```{r}
PBS |>
filter(ATC2 == "A10") |> select(Month, Concession, Type, Cost)
```

### We can use the `summarise()` function to summarise **over keys**

```{r}
PBS |>
filter(ATC2 == "A10") |>
select(Month, Concession, Type, Cost) |> summarise(total_cost = sum(Cost))

```

### We can use the `mutate()` function to create new variables

```{r}
PBS |>
filter(ATC2 == "A10") |>
  select(Month, Concession, Type, Cost)|>
  summarise(total_cost = sum(Cost)) |>
  mutate(total_cost = total_cost / 1e6) -> a10

a10
```

\newpage
# Time plots


```{r}
# autoplot() uses ggplot2 to draw a particular plot
# for an object of a particular class in a single command

a10 |> autoplot(total_cost)
```

Example 2: Ansett airlines
```{r}
ansett

ansett |> autoplot(Passengers)

```

```{r}
ansett |>
filter(Class == "Economy") |> autoplot(Passengers)
```

```{r}
ansett |>
filter(Airports == "MEL-SYD") |> autoplot(Passengers)
```


```{r}
ansett |>
filter(Airports == "MEL-SYD", Class == "Economy") |> autoplot(Passengers)
```

```{r}
ansett |>
filter(Airports == "MEL-SYD", Class == "Economy") |> autoplot(Passengers)+
  labs(title = "Ansett economy class passengers", subtitle = "Melbourne-Sydney")+
  xlab("Year")
```

# Seasonal plots

```{r}

a10

a10 |> gg_season(total_cost, labels = "both") + 
  ylab("$ million") +
  ggtitle("Seasonal plot: antidiabetic drug sales")

```

- Data plotted against the individual "seasons" in which the data were observed. (In this case a
"season" is a month.)
- Something like a time plot except that the data from each season are overlapped.
- Enables the underlying seasonal pattern to be seen more clearly, and also allows any substantial departures from the seasonal pattern to be easily identified.
- In R: `gg_season()`

```{r}
# labels: Position of the labels for seasonal period identifier.

a10 |> gg_season(total_cost, labels = "left") + 
  ylab("$ million") +
  ggtitle("Seasonal plot: antidiabetic drug sales")
```

## Seasonal subseries plots

```{r}
a10 |>
gg_subseries(total_cost) + ylab("$ million") + ggtitle("Subseries plot: antidiabetic drug sales")

```

- Data for each season collected together in time plot as separate time series.
- Enables the underlying seasonal pattern to be seen clearly, and changes in seasonality over time to be visualized.
- In R: `gg_subseries()`

Example 2: Quarterly Australian Electricity Production

```{r}

elec <- aus_production |> select(Quarter, Electricity) |> filter(year(Quarter) >= 1992)
elec
elec |> autoplot(Electricity)
```

```{r}
elec |> gg_season(Electricity, labels="right")
```

```{r}
elec |> gg_subseries(Electricity)

```


# Multiple seasonal periods

```{r}
vic_elec
```

```{r}
vic_elec |> autoplot(Demand)
```

```{r}
vic_elec |> gg_season(Demand)
```

```{r}
vic_elec |> gg_season(Demand, period = "year")
```

```{r}
vic_elec |> gg_season(Demand, period = "month")
```

```{r}
vic_elec |> gg_season(Demand, period = "week")
```

```{r}
vic_elec |> gg_season(Demand, period = "day")
```


Example 2: Australian holidays

```{r}

tourism

holidays <- tourism |>
  filter(Purpose == "Holiday") |>
  group_by(State) |>
  summarise(Trips = sum(Trips))

holidays
```


```{r}
holidays |> autoplot(Trips) +
ylab("thousands of trips") +
  xlab("Year") +
  ggtitle("Australian domestic holiday nights")
```

```{r fig.height=10, fig.width=8}
holidays |> gg_season(Trips) +
ylab("thousands of trips") + ggtitle("Australian domestic holiday nights")
```


## Seasonal subseries plots

```{r fig.height=8}
holidays |>
gg_subseries(Trips) + ylab("thousands of trips") + ggtitle("Australian domestic holiday nights")
```

# Lag plots and autocorrelation


```{r}
new_production <- aus_production |> filter(year(Quarter) >= 1992)
new_production
```


```{r}
new_production |> autoplot(Electricity) + 
  geom_point()
```

## Lagged scatterplots

```{r}
new_production |> gg_lag(Electricity)
```

```{r}
new_production |> gg_lag(Electricity, geom='point')
```

- Each graph shows $y_t$ plotted against $y_{t-k}$ for different values of $k$.
- The autocorrelations are the correlations associated with these scatterplots.
- ACF (autocorrelation function):
   - $r_1 = \text{Correlation}(y_t, y_{t-1})$
   - $r_2 = \text{Correlation}(y_t, y_{t-2})$
   - $r_3 = \text{Correlation}(y_t, y_{t-3})$
   - etc.
   
## Autocorrelation

```{r}
new_production |> 
  ACF(Electricity, lag_max = 9)
```

```{r}
 new_production |> 
  ACF(Electricity, lag_max = 9) |>
  autoplot()
```

```{r, fig.height=4}
 new_production |> 
  ACF(Electricity, lag_max = 30) |>
  autoplot()
```

# White noise

```{r}
set.seed(1)
wn <- tsibble(t = seq(36), y = rnorm(36), index = t) 

wn

wn |> autoplot(y)
```

```{r}
wn |> ACF(y)
```

```{r fig.height=3}
wn |> ACF(y) |> autoplot()
```

## Portmanteau tests for autocorrelation

$H_0: \rho_1 =\rho_2 = \dots=\rho_9=0$ 

$H_1: \text{at least one } \rho_k \neq0, \text{ for } 1\leq k \leq 9$

```{r}
# Method 1 - using stat pakcage
Box.test(wn$y, lag=10, fitdf=0, type="Lj")

# Method 2 - using fabletools package 
wn |> features(y, ljung_box, lag=10, dof = 0)
```


# References

Hyndman, R. J., & Athanasopoulos, G. (2018). Forecasting: principles and practice. OTexts.

